import { AnimationEvent } from '@angular/animations';
import { OnDestroy, OnInit } from '@angular/core';
import * as i0 from "@angular/core";
import * as i1 from "../../shared/theme.directive";
export declare class OffcanvasComponent implements OnInit, OnDestroy {
    #private;
    /**
     * Apply a backdrop on body while offcanvas is open.
     * @return boolean | 'static'
     * @default true
     */
    readonly backdrop: import("@angular/core").InputSignal<boolean | "static">;
    /**
     * Closes the offcanvas when escape key is pressed [docs]
     * @return boolean
     * @default true
     */
    readonly keyboard: import("@angular/core").InputSignalWithTransform<boolean, unknown>;
    /**
     * Components placement, there’s no default placement.
     * @return {'start' | 'end' | 'top' | 'bottom'}
     * @default 'start'
     */
    readonly placement: import("@angular/core").InputSignal<string>;
    /**
     * Responsive offcanvas property hides content outside the viewport from a specified breakpoint and down.
     * @return boolean | 'sm' | 'md' | 'lg' | 'xl' | 'xxl';
     * @default true
     * @since 4.3.10
     */
    readonly responsive: import("@angular/core").InputSignal<boolean | "sm" | "md" | "lg" | "xl" | "xxl" | undefined>;
    readonly id: import("@angular/core").InputSignal<string>;
    /**
     * Default role for offcanvas. [docs]
     * @return string
     * @default 'dialog'
     */
    readonly role: import("@angular/core").InputSignal<string>;
    /**
     * Set aria-modal html attr for offcanvas. [docs]
     * @return boolean
     * @default true
     */
    readonly ariaModal: import("@angular/core").InputSignalWithTransform<boolean, unknown>;
    /**
     * Allow body scrolling while offcanvas is visible.
     * @return boolean
     * @default false
     */
    readonly scroll: import("@angular/core").InputSignalWithTransform<boolean, unknown>;
    /**
     * Toggle the visibility of offcanvas component.
     * @return boolean
     * @default false
     */
    readonly visibleInput: import("@angular/core").InputSignalWithTransform<boolean, unknown>;
    readonly visible: import("@angular/core").WritableSignal<boolean>;
    readonly visibleEffect: import("@angular/core").EffectRef;
    /**
     * Event triggered on visible change.
     * @return <boolean>
     */
    readonly visibleChange: import("@angular/core").OutputEmitterRef<boolean>;
    readonly hostClasses: import("@angular/core").Signal<Record<string, boolean>>;
    readonly ariaHidden: import("@angular/core").Signal<true | null>;
    get tabIndex(): string | null;
    get show(): boolean;
    set show(value: boolean);
    get responsiveBreakpoint(): string | false;
    animateStart(event: AnimationEvent): void;
    animateDone(event: AnimationEvent): void;
    onKeyDownHandler(event: KeyboardEvent): void;
    ngOnInit(): void;
    ngOnDestroy(): void;
    setFocus(): void;
    private stateToggleSubscribe;
    private backdropClickSubscribe;
    protected setBackdrop(setBackdrop: boolean | 'static'): void;
    private layoutChangeSubscribe;
    static ɵfac: i0.ɵɵFactoryDeclaration<OffcanvasComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<OffcanvasComponent, "c-offcanvas", ["cOffcanvas"], { "backdrop": { "alias": "backdrop"; "required": false; "isSignal": true; }; "keyboard": { "alias": "keyboard"; "required": false; "isSignal": true; }; "placement": { "alias": "placement"; "required": false; "isSignal": true; }; "responsive": { "alias": "responsive"; "required": false; "isSignal": true; }; "id": { "alias": "id"; "required": false; "isSignal": true; }; "role": { "alias": "role"; "required": false; "isSignal": true; }; "ariaModal": { "alias": "ariaModal"; "required": false; "isSignal": true; }; "scroll": { "alias": "scroll"; "required": false; "isSignal": true; }; "visibleInput": { "alias": "visible"; "required": false; "isSignal": true; }; }, { "visibleChange": "visibleChange"; }, never, ["*"], true, [{ directive: typeof i1.ThemeDirective; inputs: { "dark": "dark"; }; outputs: {}; }]>;
}
